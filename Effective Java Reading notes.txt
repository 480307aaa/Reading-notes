【创建和销毁对象】

第一条--用静态工厂方法代替构造器
优点：
静态工厂方法相较于构造器第一大优势，工厂方法有名称，见名知意。
静态工厂方法不需要在每次调用它们时都创建一个新的对象，类似于享元模式，避免创建很多相似的对象
静态工厂方法可以返回原返回类型的任意子类型
缺点：
类如果不含有公有的或者受保护的构造器，就不能被子类化
程序员很难发下它们

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二条--遇到多个构造器参数时，要考虑使用构造器
Java创建对象的方式：
重叠构造器：第一个构造器只包含必要的参数，第二个构造器包含一个可选参数，第三个构造器包含两个可选参数，以此类推。。。但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读，搞不清每个位置的参数的意义，并且位置容易颠倒。
JavaBean模式：先调用一个午餐构造器来创建对象，然后再调用setter方法来设置每个必要的参数，以及每个相关的可选参数。这种创建对象的方式弥补了重叠构造器方式的不足，每一个参数都清晰明了但是也存在明显的不足，JavaBean模式创建的对象在构造过程中可能处于不一致的状态，因为构造过程被分在了几个调用中。
建造者模式：不直接生成想要的对象，而是由客户端利用所有可用的参数构造器得到一个builder对象，然后客户端在这个builder对象上调用类似于setter的设置方法，最后再调用空的build方法来生成不可变的对象。
Java中的实践方式：
1.类上添加@Builder+@Data注解
2.创建对象的时候使用类似于下面这样的方式来构造这个对象
MeetingSignInListVO.builder()
                .meetingId(id)
                .subject(subject)
                .attendLeaderList(attendLeaderListVO)
                .participantsList(participantsListVO)
                .unitsList(unitsListVO)
                .inviteUser(inviteUserVO)
                .attendances(attendancesVO)
                .alreadySigned(alreadySignedVO)
                .unSigned(unSignedVO)
                .build();
				
Builder模式模拟了具名的可选参数。有重叠构造器模式的安全性，也有JavaBean模式的可读性。如果类的构造器或者静态方法中有比较多的参数，设计类时，使用Builder模式

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三条--用私有构造器或者枚举类型强化singleton属性
第一种方式：公有静态成员是个final域
public class Elvis {
     public static final Elvis INSTANCE= new Elvis();
     private Elvis(...)
     public void leaveTheBuilding() { ...}
}	 
第二种方式：公有的成员是个静态工厂方法
public class Elvis {
     private static final Elvis INSTANζE = new Elvis();
     private Elvis(...)
     public static Elvis getInstance() ｛return INSTANCE; }
     public void leaveTheBuilding() { ... }
}
第三种方式：声明一个包含单个元素的枚举类型，单元素的枚举类型经常成为实现 Singleton 的最佳方法，但是当Singleton必须扩展一个超类时，而不是扩展Enum时，此方法不合适
public enum Elvis {
     INSTANCE;
     public void leaveTheBuilding() { .. . }
}

序列化当面对单例对象时会遇到问题，将磁盘中对象反序列化至内存中时，会创建多余的对象，此时需要使用readResolve方法，
这样，当JVM从内存中反序列化地"组装"一个新对象时，就会自动调用这个 readResolve方法来返回我们指定好的对象了，单例规则也就得到了保证。
private Object readResolve() throws ObjectStreamException {
       // instead of the object we're on,
       // return the class variable INSTANCE
      return INSTANCE;
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第四条--通过私有构造器强化不可实例化的能力
有时可能需要编写只包含静态方法和静态域的类，比如一些工具类，它们不希望被实例化和子类化，
public class UtilityClass{

	private UtilityClass(){
		throw new AssertionError();
	}
}
// 因为不写throw new AssertionError()时在类内部可以正常初始化，这样就可以保证在类的内外都无法调用此构造方法实例化该类。
企图通过将类做成抽 象类来强制该类不可被实例化是行不通的。让这个类包含一个私有构造器，它就不能被实例化 ,但是这种习惯用法也有副作用，它使得一个类不能被子类化 。 因为所有的构造器都必须显式或隐式地调用超类（ superclass ）构造器，在这种情形下，子类就没有可访问的超类构造器可调用了

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五条--优先考虑依赖注人来引用资源（一直都在用，但是不知道规则名字）
不要用 Singleton 和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为 ；也不要直接用这个类来创建这些资源 。 而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类 。这个实践就被称作依赖注入，它极大地提升了类的灵活性 、可重用性和可测试性
publ ic class SpellChecker｛
    //在SpellChecker类中以构造器参数的方式引入Lexicon类
	private final Lexicon dictionary;
    public SpellChecker(Lexicon dictionary) {
    this.dictionary = Objects requireNonNull(dictionary);
	}
    ......
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第六条--避免创建不必要的对象
1）String s='Hello'和 String s=new String('Hello')两种方式是不同的
2）创建 Pattern实例的戚本很高 ，因为需要将正则表达式编译成一个有限状态机，为了提升性能，应该显式地将正则表达式编译成一个 Pattern实例（不可变），让它成为类初始化的一部分，并将它缓存起来
也就是：Pattern pattern=Pattern.compile('正则表达式')的用法
3）定义long型变量：使用long而不是包装类Long,比如在下面的程序中，会生成大量的包装类对象：
变量 sum 被声明成 Long 而不是 long ，意味着程序构造了大约 2^31 个多余的 Long 实例（大约每次往 Long sum 中增加long时构造一个实例） 

private static long sum(){
	Long sum=0L;
	for(long i=0;i<-Integer.MAX_VALUE;i++){
		sum+=i;
	}
	return sum;
}
因此，要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第七条--消除过期的对象引用

一旦对象引用已经过期，只需清空这些引用即可
public Object pop(){
	if(size==0){
		throw new EmptyStackException();
	}
	Object result=elements[--size];
	elements[size]=null;
	return result;
}
如果它们以后又被错误地解除引用，程序就会立即抛出 NullPointerException异常,而不是悄悄地错误运行下去

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第八条--避免使用终结方法和清除方法
终结方法（ finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的 。在 Java 9中用清除方法（ cleaner）代替了终结方法 。 清除方法没有终结方法那么危险，但仍然是不可
预测、运行缓慢，一般情况下也是不必要的 。
Java 语言规范不仅不保证终结方法或者清除方法会被及时地执行，而且根本就不保证它们会被执行

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第九条--try-with-resources 优先于 try-finally

旧版关闭资源：
public void test4() {
    InputStream inputStream = null;
    try {
        inputStream = new FileInputStream("D:\\head.jpg");
        // do something
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

这种写法的麻烦之处在于，我们需要在finally块中关闭资源，所以inputStream只能定义在try块的外面。关闭之前，还需要做一步判空，避免因为inputStream为空而导致的空指针异常。这种写法是很繁琐的。

新版关闭资源
同样的功能，如果采用try-with-resources，就会使代码变得非常简洁：
@Test
public void test5() {
    try (InputStream inputStream = new FileInputStream("D:\\head.jpg")) {
        byte[] bytes = inputStream.readAllBytes();
        // do something
    } catch (IOException e) {
        e.printStackTrace();
    }
}

带资源的try语句的3个关键点：

1、由带资源的try语句管理的资源必须是实现了AutoCloseable接口的类的对象。

2、在try代码中声明的资源被隐式声明为fianl。

3、通过使用分号分隔每个声明可以管理多个资源。
当需要关闭的资源有多个，也就是try-finally有嵌套时，如果抛出异常，异常消息可能会出现覆盖，在异常堆轨迹中，完全没有关于第一个异常的记录，这在现实的系统中会导致调试变得非常复杂，
因为通常需要看到第一个异常才能诊断出问题何在。
总结：
try-with-resources可以使代码更加简洁而且不容易出错。相比传统的try-catch-finally的写法，显然try-with-resources优点更多，至少不会存在finally关闭资源因为没判空而导致空指针的问题


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



【对于所有对象都通用的方法】

第十条--覆盖equals时请遵守通用约定
什么时候不需要考虑覆盖equals方法？
1）类的每个实例本质上都是唯一的，比如Thread。
2）类没有必要提供‘逻辑相等’的测试功能，比如正则表达式pattern类，不需要提供两个pattern是否代表同一个正则表达式
3）超类已经覆盖了equals，超类的行为对于这个类也是合适的，比如Set/List/Map,它们都继承自各自的超类AbstractXXX;
4)类时私有的，或者是包级私有的，可以确定它的equals方法永远不会被调用
什么时候需要覆盖equals方法？
先看一下Object的equals方法的源码：比较的是两个对象是否相同，即物理和逻辑都要相等，值相等，并且指向同一段物理地址
 public boolean equals(Object obj) {
        return (this == obj);
 }
如果类具有自己特有的“逻辑相等”（ logical equality ）概念（不同于对象等同的概念），而且超类还没有覆盖 equals 。这通常属于“值类”（ value class ）的情形 。 值类仅仅是一个表示值的类，例如Integer或者String 。程序员在利用equals方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象 。 
下面是String类覆盖equals方法的源码实现：先比较引用，引用一致则相等，否则比较值，值相等则相等。

 public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
 }
下面是Integer基本数据类型覆盖父类equals方法的源码实现：只比较值是否相等
 public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
 }
 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十一条--覆盖equals时总要覆盖hashCode

1)在每个覆盖了equals方法的类中，都必须覆盖hashCode方法。
2)不要企图让equals方法过于智能 。
3)不要将equals声明中的Object对象替换为其他的类型
相同的实例，其散列码一定相同，不同的实例，其散列码也可能相同
String类的hashCode方法源码：
public int hashCode() {
	int h = hash;
	if (h == 0 && value.length > 0) {
		char val[] = value;

		for (int i = 0; i < value.length; i++) {
			h = 31 * h + val[i];
		}
		hash = h;
	}
	return h;
}
举例说明：假设有一个PhoneNumber类，只需两个实例的prefix和lineNumber属性相等，即可认为两个PhoneNumber相等：（该例子来自于：https://www.jianshu.com/p/6ceec4d542f8）
public class PhoneNumber {
    private short areaCode;
    private short prefix;//关键属性
    private short lineNumber;//关键属性

    public PhoneNumber(short areaCode, short prefix, short lineNumber) {
        this.areaCode = areaCode;
        this.prefix = prefix;
        this.lineNumber = lineNumber;
    }

    public boolean equals(Object o) {
        if(o == this) {
            return true;
        }

        if(!(o instanceof PhoneNumber)) {
            return false;
        }

        PhoneNumber compareO = (PhoneNumber)o;

        return compareO.prefix == this.prefix
                && compareO.lineNumber == this.lineNumber;
    }
}

然后将PhoneNumber与HashMap一起使用：
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(21, 37, 3245), "xiaobai");‘

System.out.println(m.get(new PhoneNumber(53, 37, 3245)));//输出：null
你可能期望输出的是："xiaobai"，因为put和get的两个key对象的equals返回是true，但实际上得到的却是null，为什么呢？原因就在于未覆盖hashCode，两个对象即便相等，但是其hashCode还是可能不等，那么put方法把PhoneNumber对象存放至一个散列桶（hashbucket）中，而get方法却在另外一个散列桶中查找这个对象，当然找不到，退一步说，即便是两个实例刚好被放至于同一个散列桶中，get方法依然还是会返回null，因为HashMap有一项机制：如果两个实例散列码不匹配，直接放弃比较其等同性

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


第十二条--始终要覆盖toString
基本数据类型和String都已经覆盖父类toString方法
Object类的toString()方法源码：它包含类的名称，以及一个“＠”符号，接着是散列码的无符号十六进制表示法，比如MyClass@19765
public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
在实际应用中，toString方法应该返回对象中包含的所有值得关注的信息，无论是否决定指定格式，都应该在文档中明确地表明你的意图，toString方法应该有简洁的格式和详细的描述。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十三条--谨慎地覆盖clone
Cloneable接口不包含任何的方法
public interface Cloneable {
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十四条--考虑实现Comparable接口
Comparable接口中只有一个方法：compareTo
public interface Comparable<T> {
	 public int compareTo(T o);
}

类实现了 Comparable 接口，就表明它的实例具有内在的排序关系(natural ordering ）。为实现 Comparable 接口的对象数组进行排序就这么简单 ：Arrays.sort(a);
Java 平台类库中的所有值类(value classes)，以及所有的枚举类型(详见第 34 条)都实现了 Comparable 接口.
Java7之后提供了compare方法去具体实现compareTo方法，比如下面的Integer包装类的compareTo方法的具体实现：
public static int compare(int x, int y) {
	return (x < y) ? -1 : ((x == y) ? 0 : 1);
}
总而言之，每当实现一个对排序敏感的类时，都应该让这个类实现 Comparable 接口，以便其实例可以轻松地被分类 、搜索，以及用在基于比较的集合中 。每当在 compareTo 方法的实现中比较域值时，都要避免使用 ＜ 和＞操作符,两种使用方法：
1）应该在装箱基本类型的类中使用静态的 compare 方法
static Comparator<Object> hashCodeOrder=new Comparator<>(){
	public int compare(Object o1,Object O2){
		return Integer.compare(O1.hashCode,O2.hashCode);
	}
};
2）在 Comparator 接口中使用比较器构造方法 
static Comparator<Object> hashCodeOrder=Comparator.comparingInt(0->o.hashCode());

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

【类和接口】

第十五条--使类和成员的可访问性最小化
几个关键字：信息隐藏、封装、解耦、访问控制、访问修饰符(private,public ,protected，package-private)，组件之间只以API进行通信。
规则要求：尽可能的使每个类或者成员不被外界访问
应该防止把任何散乱的类、接口或者成员变成 API 的一部分。 除了公有静态 final 域的特殊情形之外（此时它们充当常量），公有类都不应该包含公有域，并且要确保公有静态 final 域所引用的对象都是不可变的.（不可以引用数组这种可变的结构） 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十六条--要在公有类而非公有域中使用访问方法
公有类永远都不应该暴露可变的域。 虽然还是有问题，但是让公有类暴露不可变的域，其危害相对来说比较小 。 但有时候会需要用包级私有的或者私有的嵌套类来暴露域，无论这个类是可变的还是不可变的

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十七条--使可变性最小化
为了使类成为不可变，要遵循的五条规则：
1.不要提供任何会修改对象状态的方法（比如setter方法等其他设值方法）
2.保证类不会被扩展，一般的做法就是把这个类设置成final的，还有其他的方法。
3.声明所有的域都是final的
4.声明所有的域都为私有的
5.确保对于任何可变组件的互斥访问

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十八条--复合优先于继承
包内部的继承是非常安全的，跨包继承应该被杜绝。我们这里说的继承是指实现继承（当一个类扩展一个类的行为），本条目讨论的规则不适用于接口的继承
与方法调用不同的是，继承打破了封装性
复合的定义：不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，现有的类变成了新类的一个组件
只有当子类真正是超类的子类型（ subtype）时，才适合用继承,换句话说，对于两个类A 和 B ，只有当两者之间确实存在“ is-a ”关系的时候，类 B 才应该扩展类 A 
即使如此，如果子类和超类处在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性( fragility ）。为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当
的接口可以实现包装类的时候

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十九条--要么设计继承并提供文档说明，要么禁止继承

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十条--接口优于抽象类

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十一条--为后代设计接口

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十二条--接口只用于定义类型
当类实现接口时 ，接口就充当可以引用这个类的实例的类型（type ）。因此，类实现了接口，就表明客户端可以对这个类的实例实施某些动作。 为了任何其他目的而定义接口是不恰当的

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十三条--类层次优于标签类

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十四条--静态成员类优于非静态成员类

静态成员类的一种常见用法是作为公有的辅助类，只有与它的外部类一起使用才有意义，比如：
@Data
public static class PendingQueryVO {

	private Long memberId;

	private String name;

	private IdentityType identityType;
}

非静态内部类持有外部类的this引用，保存这份引用要消耗时间和空间，并且会导致外围实例在符合垃圾回收（详见第 7 条）时’却仍然得以保留 。由此造成的内存泄漏可能是灾难性的 。
四种不同的嵌套类：
如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的；否则，就做成静态的。
假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类 ；否则，就做成局部类

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十五条--限制源文件为单个顶级类
限制源文件为单个顶级类，遵循这个规则可以确保编译时一个类不会有多个定义 。 这么做反过来也能确保编译产生的类文件，以及程序结果的行为，都不会受到源文件被传给编译器时的顺序的影响 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


【泛型】
没有泛型之前，从集合中读取到的每一个对象都必须进行转换 。如果有人不小心插入了类型错误的对象，在运行时的转换处理就会出错 。有了泛型之后，你可以告诉编译器每个集合中接受哪些对象类
型。编译器自动为你的插入进行转换，并在编译时告知是否插入了类型错误的对象。这样可以使程序更加安全，也更加清楚

第二十六条--请不要使用原生态类型
原生态类型：List/Set/Map等
泛型：泛型类+泛型接口，泛型信息在运行时会被擦除。如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势，其实现在写代码过程中很少直接用原生态类型了，一般都是List<Integer> list=new ArrayList<>()等写法
如果要使用泛型，但不确定或者不关心实际的类型参数，就可以用一个问号代替。例如，泛型 Set<E＞的无限制通配符类型为 Set <?>（读作“某个类型的集合”），通配符类型是安全的，原生态类型则不安全。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十七条--消除非受检的警告
SuppressWarnings注解可以用在任何粒度的级别中，从单独的局部变量声明到整个类都可以。应该始终在尽可能小的范围内使用 SuppressWarnings 注解。它通常是个变量
声明，或是非常简短的方法或构造器 。永远不要在整个类上使用SuppressWarnings ，这么做可能会掩盖重要的警告。
Java受检异常和非受检异常：
Java中异常的分类
Java中所有异常，都继承自java.lang.Throwable类。
Throwable有两个直接子类，Error类和Exception类。


1.Error错误：JVM内部的严重问题。无法恢复。程序人员不用处理。
2.Exception异常：普通的问题。通过合理的处理，程序还可以回到正常执行流程。要求编程人员要进行处理。
3.RuntimeException:也叫非受检异常(unchecked exception).这类异常是编程人员的逻辑问题。应该承担责任。Java编译器不进行强制要求处理。 也就是说，这类异常再程序中，可以进行处理，也可以不处理。
4.受检异常(checked exception).这类异常是由一些外部的偶然因素所引起的。Java编译器强制要求处理。也就是说，程序必须进行对这类异常进行处理。

常见异常：
1)非受检的：NullPointerException,ClassCastException,ArrayIndexsOutOfBoundsException,ArithmeticException(算术异常，除0溢出)
2)受检：Exception,FileNotFoundException,IOException,SQLException.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十八条--列表优于数组
//运行时才发现错误
Object[] objectArray=new Long[1];
objectArray[0]='I don't fit it';
//编译时就能发现错误
List<Object> o1=new ArrayList<Long>();
o1.add('I don't fit it');
数组和列表的区别：
1）数组是协变的，而泛型是可变的
2）数组是具体化的，数组会在运行时知道和强化它们的元素类型 ，泛型是通过擦除来实现的，泛型只是在编译器强化数据的类型信息，在运行时擦除类型信息，方便同其他没有泛型的数据互用。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二十九条--优先考虑泛型

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十条--优先考虑泛型方法

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十一条--利用有限制通配符来提升 API 的灵活性
Iterable<? extends E＞：E的某个子类型的 Iterable 接口
Collection<? super E＞：E的某种超类的集合
选择使用哪种通配符类型的原则：
PECS 表示 producer-extends, consumer－super，如果参数化类型表示一个生产者 T ，就使用＜？extends T＞；如果它表示一个消费者 T ，就使用＜？super T＞

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十二条--谨慎并用泛型和可变参数

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十三条--优先考虑类型安全的异构容器

【枚举和注解】
Java 支持两种特殊用途的引用类型：一种是类，称作枚举类型(enum type)；一种是接口，称作注解类型(annotation type)。 

第三十四条--用enum代替int

int 枚举模式，编译时常量，数值有变，需要重新编译，否则，行为不准
public static final int APPLE_FUI = 0;
public static final int APPLE_PIPPIN ＝1；
public static final int APPLE_GRANNY_SMITH = 2;

String 枚举模式
private final static String QZ_ID_TENANT_ID_KEY = "qz::%s::tenant";

枚举类型
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange｛ NAVEL, TEMPLE, BLOOD }

一个例子：
public enum SecurityType {

    /**
     * 公开
     */

    PUBLIC("1", "gk", "公开", 0),

    INTERNAL("2", "nb", "内部", 1),

    SECRET("3", "mm", "秘密", 2),

    CONFIDENTIAL("4", "jm", "机密", 3);

    private String id;

    private String code;

    private String name;

    private Integer value;

    SecurityType(String id, String code, String name, Integer value) {
        this.id = id;
        this.code = code;
        this.name = name;
        this.value = value;
    }


    public String id() {
        return id;
    }

    public String code() {
        return code;
    }

    public String getName() {
        return name;
    }

    public Integer getValue() {
        return value;
    }


    public static SecurityType getEnumTypeByValue(Integer securityTypeValue) {

        for (SecurityType type : SecurityType.values()) {
            if (type.getValue().equals(securityTypeValue)) {
                return type;
            }
        }
        return null;
    }

    public static SecurityType getEnumTypeById(String id) {
        for (SecurityType type : SecurityType.values()) {
            if (type.id().equals(id)) {
                return type;
            }
        }
        return null;
    }

    public static SecurityType getEnumTypeByCode(String code) {
        for (SecurityType type : SecurityType.values()) {
            if (type.code().equals(code)) {
                return type;
            }
        }
        return null;
    }

    public static Map<Integer, String> listAllTypes() {
        SecurityType[] types = SecurityType.values();
        Map<Integer, String> map = new HashMap<>(types.length);
        for (SecurityType type : types) {
            map.put(type.getValue(), type.getName());
        }
        return map;
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十五条--用实例域代替序数

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十六条--用EnumSet代替位域
这种表示法让你用 OR 位运算将几个常量合并到一个集合中，称作位域（ bit field) :text.applyStyles(STYLE BOLD | STYLE_ITALIC);
EnumSet类来有效地表示从单个枚举类型中提取的多个值的多个集合 
一个例子：
    /**
     * 返回会议室支持的密级
     *
     * @param id 会议室id
     * @return 会议室支持的密级
     */
    @GetMapping("security_type/list/{id}")
    public JSONObject listSupportedSecurityType(@PathVariable("id") String id) {

        EnumSet<SecurityType> securityTypes;
        try {
            securityTypes = meetingRoomService.querySupportedSecurityType(id);
            return success(buildSecurityTypeList(securityTypes));
        } catch (ECIllegalArgumentException e) {
            return fail(null, e.getMessage());
        }
    }
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十七条--用EnumMap代替序数索引

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十八条--用接口模拟可扩展的枚举

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三十九条--注解优先于命名模式

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第四十条--坚持使用Override注解
如果在你想要的每个方法声明中使用 Override 注解来覆盖超类声明，编译器就可以替你防止大量的错误，但有一个例外 。在具体的类中，不必标注你确信覆盖了抽
象方法声明的方法（虽然这么做也没有什么坏处） 。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第四十一条--用标记接口定义类型

标记接口（marker interface）：没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口。例如，Serializable(对象可序列化)、Cloneable（克隆）接口。
Serializable:
public interface Serializable {
}

Cloneable
public interface Cloneable {
}
标记注解（marker annotation）：特殊类型的注解，其中不包含成员。标记注解的唯一目的就是标记声明。例如，@Override（覆盖超类）。
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
总结：如果想要定义类型，一定要使用接口

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

【lambda和Stream】

在 Java 8 中，增加了函数接口（ functional interface ）、Lambda和方法引用（ method reference ），使得创建函数对象（fuction object）变得很容易 。与此同时，还增加了Stream
API，为处理数据元素的序列提供了类库级别的支持 。在本章中，将讨论如何最佳地利用这些机制。

第四十二条--lambda优先于匿名类

匿名类的常规用法：匿名类满足了传统的面向对象的设计模式对函数对象的需求,策略模式就是这样，接口方法可以随意切换策略（更换实现方法）详细见我的博客：https://www.cnblogs.com/ysw-go/p/5379971.html
Collection.sort(words,new Comparator<String>(){
	public int compare(String s1,String s2){
		return Integer.compare(s1.length(),s2.length());
	}
  }
)
函数接口：带有单个抽象方法的接口
Collections.sort(words,(s1,s2)->Integer.compare(s1.length(),s2.length()));
还可以更简洁：
String[] m={"zzy","znm","it"};
Arrays.sort(m, (o1, o2) -> o1.length()-o2.length());
在Jdk1.8之后，新增了comparingXXX等方法，可以更加简洁：
String[] m={"zzy","znm","it"};
Arrays.sort(m, comparingInt(String::length));
总结一下：Lambda是表示小函数对象的最佳方式，千万不要给函数对象使用匿名类，除非必须创建非函数接口的类型的实例。打开了从未实践过的在Java中进行函数编程的大门。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第四十三条--方法引用优先于lambda表达式
方法引用，像上一条的Arrays.sort(m, comparingInt(String::length));这样就是运用的方法引用
方法引用常常比lambda表达式更加的简洁明了，只要方法引用更加简洁，清晰，就用方法引用；如果方法引用并不简洁，就坚持使用lambda

第四十四条--坚持使用标准的函数接口

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


第四十五条--谨慎使用Stream
Java 8增加的Stream API，提供了两个关键的抽象：
1)Stream(流)代表的数据元素有限或者无线的顺序
2)String pipline代表这些元素的一个多级计算
Map<String, List<MeetingRoomDO>> roomMap = meetingRoomDOS.stream()
                .filter(room -> StringUtils.isNotBlank(room.getType()))
                .collect(Collectors.groupingBy(MeetingRoomDO::getType, Collectors.toList()));
Stream pipeline 通常是 lazy 的 ：直到调用终止操作时才会开始计算 ，对于完成终止操作不需要的数据元素，将永远都不会被计算 
默认情况下， Stream pipeline 是按顺序运行的 。 要使 pipelin巳并发执行，只需在该pipeline 的任何 Stream 上调用 parallel 方法即可，但是通常不建议这么做。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第四十六条--优先选择Stream中无副作用的函数
Stream收集器：toList、toSet、toMap、groupingBy和joining，经过一系列的中间计算，得到最后的计算结果。
给出一个例子：是在实现一个excle导出功能时准备表头时的操作：
 //将查询到的数据转成list形式存储
List<Object[]> res = signPersonVOS.stream().map(signPersonVO -> new Object[]{
		signPersonVO.getName(), signPersonVO.getDeptName(), signPersonVO.getSigned(), null}).
		collect(Collectors.toList());
		
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
第四十七条--Stream要优先使用Collection作为返回类型

第四十八条--谨慎使用Stream并行
总而言之，尽量不要并行 Stream pipeline ，除非有足够的理由相信它能保证计算的正确性，并且能加快程序的运行速度 。 如果对 Stream 进行不恰当的并行操作，可能导致程序运
行失败，或者造成性能灾难 。 如果确信并行是可行的，并发运行时一定要确保代码正确，并在真实环境下认真地进行性能测量
下面给出一个例子：并行更改记录索引值的功能，批量更新
meetingTypeDOS.parallelStream().forEach(meetingTypeRepository::updateIndex);
另外一个例子：是构建参会领导的个人信息的处理：
leaderList.parallelStream().forEach(leader -> {
            MeetingLeaderMeetingDO leaderMeetingDO = MeetingLeaderMeetingDO.builder()
                    .qzId(qzId)
                    .memberId(leader)
                    .meetingId(meetingId)
                    .start(start)
                    .end(end)
                    .build();

            leaderMeetingRepository.save(leaderMeetingDO);
});
类似于这些功能实现,parallelStream确实能够发挥其最大性能，否则，谨慎使用parallelStream。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

【方法】

如何处理参数和返回值，如何设计方法签名，如何为方法编写文档。注重可用性、灵活性、健壮性
第四十九条--检查参数的有效性
这里学到了一个Java7 添加进来的不需要人工去判断是否为null的方法：Objects.requireNonNull,下面的例子是把流中的数据写出到输出流，保证每一个字符都不为null（导出excle表格工具类用到的方法）
// 循环取出流中的数据
byte[] b = new byte[100];
int len;
try {
	while ((len = Objects.requireNonNull(inStream).read(b)) > 0) {
		response.getOutputStream().write(b, 0, len);
	}
} catch (IOException e) {
	log.error("error is : {} ", e);
}
总结:
简而言之，每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制 。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来实施这些限制。养成
这样的习惯是非常重要的 。只要有效性检查有一次失败，你为必要的有效性检查所付出的努力便都可以连本带利地得到偿还了 。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五十一条--谨慎的设计方法签名
1）谨慎的是选择方法的名称
2）不要孤独追求提供便利的方法
3）避免过长的参数列表
4）对于参数类型，要优先使用接口而不是类
5）对于boolean参数，要优先使用两个元素的枚举类型

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五十二条--慎用重载
属性找编译，方法找运行
比如
public class Animal {
    public String name = "Animal";

    public void dinner() {
        System.out.println("Animal dinning");
    }
}
//子类
public class Cat extends Animal {
    public String name = "Cat";

    @Override public void dinner() {
        System.out.println("Cat dinning");
    }
}
//测试代码
public class Main {

    public static void main(String[] args) {
        Animal animal=new Cat();
        System.out.println(animal.name);//Animal
        animal.dinner();//Cat dinning
    }
}
则访问对应的属性和方法，则会出现下面的情况：
Animal animal=new Cat();
System.out.println(animal.name);//Animal
animal.dinner();//Cat dinning

对于多个具有相同参数数目的方法来说，应该尽量避免重载方法
Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态。因为子类其实是一种特殊的父类，因此java允许把一个子类对象直接赋值给一个父类引用变量，无须任何类型转换，或者被称为向上转型，由系统自动完成。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五十三条--慎用可变参数
可变参数方法：它接受 0 个或者多个指定类型的参数 。可变参数机制首先会创建一个数组，数组的大小为在调用位置所传递的参数数量 ，然后将参数值传到数组中，最后将数组传递给方法
性能问题：每次调用可变参数方法都会导致一次数组分配和初始化
总结：
简而言之，在定义参数数目不定的方法时，可变参数方法是一种很方便的方式 。在使用可变参数之前，要先包含所有必要的参数，并且要关注使用可变参数所带来的性能影响 
比如： 
LineDash(int nativeId, int ooxmlId, int... pattern) {
	this.nativeId = nativeId;
	this.ooxmlId = ooxmlId;
	this.pattern = (pattern == null || pattern.length == 0) ? null : pattern;
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五十四条--返回零长度的数组或者集合，而不是 null
这一点在现在的编码过程中经常遇到，下面给出一个例子来说明这一点
 private List<String> fetchRoomIds(String deptId) {
	List<MeetingRoomVO> roomVOS = meetingRoomService.queryByDeptId(deptId, null);
	if (roomVOS.isEmpty()) {
		return Collections.emptyList();
	}
	return roomVOS.stream().map(MeetingRoomVO::getId).collect(Collectors.toList());
}
按照自己的习惯，一般会选择返回null，但是当和前端联调接口时，他们的习惯是如果返回空集合则说明不包含任何元素，而且可以省略判空这一步。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五十六条--为所有导出的 API 元素编写文档注释
1)为了正确地编写 API 文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释 
2)方法的文档注释应该简洁地描述出它和客户端之间的约定.
3)当为泛型或者方法编写文档时，确保要在文档中说明所有的参数类型。
4)当为枚举类型编写文档时，要确保在文档中说明常量
5)当为注解类型编写文档时，要确保在文档中说明所有成员

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

【通用编程】

讨论 Java 语言的细枝末节，包含局部变量的处理、控制结构、类库的用法、各种数据类型的用法，以及两种不是由语言本身提供的机制（反射机制和本地方法）的用法 。最后讨论了优化和命名惯例 。

第五十七条--将局部变量的作用域最小化
1）要使局部变量的作用域最小化 ，最有力的方法就是在第一次要使用它的地方进行声明 。
2）几乎每一个局部变量的声明都应该包含一个初始化表达式 。
3）最后一种“将局部变量的作用域最小化”的方法是使方法小而集中

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五十八条--for-each 循环优先于传统的 for 循环

与传统的 for 循环相比， for-each 循环在简洁性、灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。 因此，当可以选择的时候， for-each 循环应该优先于 for 循环

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五十九条--了解和使用类库

java.util.Random 类用于生成随机数，在多线程环境下性能不佳，因为多个线程共同争用Random实例
从 Java 7 开始，就不应该再使用 Random 了 。现在选择随机数生成器时，大多使用 ThreadLocalRandom
应该熟悉 java.lang 、java.util、java.io 及其子包中的内容

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第六十条--如果需要精确的答案，请避免使用double或者float
总而言之，对于任何需要精确答案的计算任务，请不要使用 float 或者 double 。
如果你想让系统来处理十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用BigDecimal。使用BigDecimal还有一些额外的好处，它允许你完全控制舍人，每当一个操作涉及舍入的时候，你都可以从 8 种舍入模式中选择其－ 。如果你正通过合法强制的舍入行为进行商务计算，使用 BigDecimal 是非常方便的. 如果性能非常关键，并且你又不介意自己处理十进制小数点，而且所涉及的数值又不太大，就可以使用 int 或者 long 。
如果数值范围没有超过 9 位十进制数字,就可以使用Int :如果不超过 18 位数字，就可以使用long 。如果数值可能超过 18 位数字，就必须使用BigDecimal 

public static Long toScaleLong(String amount) {
        BigDecimal b1 = new BigDecimal(amount);
        BigDecimal b2 = new BigDecimal(100);
        return b1.multiply(b2).longValue();
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第六十一条--基本类型优先于装箱基本类型
Java类型系统：基本数据类型+引用类型，每个基本类型都有对应的引用类型
需要注意的几个点：
1.基本类型通常比装箱类型更节省时间和空间
2.对装箱基本类型运用'=='操作符几乎都是错误的。
3.当在一项操作中混用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱。
这一点不太明白，为啥在Springboot项目中，pojo基本类的属性字段的定义都是装箱类型，而不是基本类型？
在这篇博文中我找到了答案：https://juejin.im/post/5d8ff563f265da5bb252de76
结合这篇博文，给出基本类型和装箱类型之间的区别：
1）包装类型可以为null，而基本类型不可以
举个例子：在Springboot项目中，pojo中可以应用包装类型，不能用基本类型。和POJO类似的，还有数据传输对象DTO(Data Transfer Object,泛指用于展示层与服务层之间的数据传输对象)、视图对象（View Object,把某个页面的数据封装起来）、持久化对象PO（Persiste Object，可以看成是与数据库中的表映射的Java对象）
那为什么POJO的属性必须要用包装类型呢？
数据库的查询结果可能为null，如果使用基本类型的话，因为要自动拆箱，就会抛出nullPointer的异常
2）包装类型可用于泛型，而基本类型不可以
因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是Object类及其子类--基本类型是个特例
3）基本类型比包装类更高效
基本类型是在栈中直接存储的具体数值，而包装类型则存储的是在堆中的引用。、
4）两个包装类型的值可以相同，但却不相等
Integer chenmo = new Integer(10);
Integer wanger = new Integer(10);

System.out.println(chenmo == wanger); // false
System.out.println(chenmo.equals(wanger )); // true

包装类型：
1）用equals判断比较的是两个int值是否相等
2）用‘==’判断比较的是其指向的地址是否相等
此处介绍一下Integer的缓存机制：也就是下面这个函数搞得鬼，
private static class IntegerCache {
  static final int low = -128;
  static final int high;
  static final Integer cache[];

  static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
      sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
    if (integerCacheHighPropValue != null) {
      try {
        int i = parseInt(integerCacheHighPropValue);
        i = Math.max(i, 127);
        // Maximum array size is Integer.MAX_VALUE
        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
      } catch( NumberFormatException nfe) {
        // If the property cannot be parsed into an int, ignore it.
      }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k < cache.length; k++)
      cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high >= 127;
  }

  private IntegerCache() {}
}

从以上代码中可以看到默认会把 -128 到 127的值缓存起来，因此会有下面的结果
public static void main(String[] args) {
  Integer l1 = 120;
  Integer l2 = 120;
  Integer l3 = 128;
  Integer l4 = 128;
  System.out.println(l1 == l2); //true
  System.out.println(l3 == l4); //false
}


 









	



