创建和销毁对象

第一条--用静态工厂方法代替构造器
优点：
静态工厂方法相较于构造器第一大优势，工厂方法有名称，见名知意。
静态工厂方法不需要在每次调用它们时都创建一个新的对象，类似于享元模式，避免创建很多相似的对象
静态工厂方法可以返回原返回类型的任意子类型
缺点：
类如果不含有公有的或者受保护的构造器，就不能被子类化
程序员很难发下它们

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二条--遇到多个构造器参数时，要考虑使用构造器
Java创建对象的方式：
重叠构造器：第一个构造器只包含必要的参数，第二个构造器包含一个可选参数，第三个构造器包含两个可选参数，以此类推。。。但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读，搞不清每个位置的参数的意义，并且位置容易颠倒。
JavaBean模式：先调用一个午餐构造器来创建对象，然后再调用setter方法来设置每个必要的参数，以及每个相关的可选参数。这种创建对象的方式弥补了重叠构造器方式的不足，每一个参数都清晰明了但是也存在明显的不足，JavaBean模式创建的对象在构造过程中可能处于不一致的状态，因为构造过程被分在了几个调用中。
建造者模式：不直接生成想要的对象，而是由客户端利用所有可用的参数构造器得到一个builder对象，然后客户端在这个builder对象上调用类似于setter的设置方法，最后再调用空的build方法来生成不可变的对象。
Java中的实践方式：
1.类上添加@Builder+@Data注解
2.创建对象的时候使用类似于下面这样的方式来构造这个对象
MeetingSignInListVO.builder()
                .meetingId(id)
                .subject(subject)
                .attendLeaderList(attendLeaderListVO)
                .participantsList(participantsListVO)
                .unitsList(unitsListVO)
                .inviteUser(inviteUserVO)
                .attendances(attendancesVO)
                .alreadySigned(alreadySignedVO)
                .unSigned(unSignedVO)
                .build();
				
Builder模式模拟了具名的可选参数。有重叠构造器模式的安全性，也有JavaBean模式的可读性。如果类的构造器或者静态方法中有比较多的参数，设计类时，使用Builder模式

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三条--用私有构造器或者枚举类型强化singleton属性
第一种方式：公有静态成员是个final域
public class Elvis {
     public static final Elvis INSTANCE= new Elvis();
     private Elvis(...)
     public void leaveTheBuilding() { ...}
}	 
第二种方式：公有的成员是个静态工厂方法
public class Elvis {
     private static final Elvis INSTANζE = new Elvis();
     private Elvis(...)
     public static Elvis getInstance() ｛return INSTANCE; }
     public void leaveTheBuilding() { ... }
}
第三种方式：声明一个包含单个元素的枚举类型，单元素的枚举类型经常成为实现 Singleton 的最佳方法，但是当Singleton必须扩展一个超类时，而不是扩展Enum时，此方法不合适
public enum Elvis {
     INSTANCE;
     public void leaveTheBuilding() { .. . }
}

序列化当面对单例对象时会遇到问题，将磁盘中对象反序列化至内存中时，会创建多余的对象，此时需要使用readResolve方法，
这样，当JVM从内存中反序列化地"组装"一个新对象时，就会自动调用这个 readResolve方法来返回我们指定好的对象了，单例规则也就得到了保证。
private Object readResolve() throws ObjectStreamException {
       // instead of the object we're on,
       // return the class variable INSTANCE
      return INSTANCE;
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第四条--通过私有构造器强化不可实例化的能力
有时可能需要编写只包含静态方法和静态域的类，比如一些工具类，它们不希望被实例化和子类化，
public class UtilityClass{

	private UtilityClass(){
		throw new AssertionError();
	}
}
// 因为不写throw new AssertionError()时在类内部可以正常初始化，这样就可以保证在类的内外都无法调用此构造方法实例化该类。
企图通过将类做成抽 象类来强制该类不可被实例化是行不通的。让这个类包含一个私有构造器，它就不能被实例化 ,但是这种习惯用法也有副作用，它使得一个类不能被子类化 。 因为所有的构造器都必须显式或隐式地调用超类（ superclass ）构造器，在这种情形下，子类就没有可访问的超类构造器可调用了

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五条--优先考虑依赖注人来引用资源（一直都在用，但是不知道规则名字）
不要用 Singleton 和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为 ；也不要直接用这个类来创建这些资源 。 而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类 。这个实践就被称作依赖注入，它极大地提升了类的灵活性 、可重用性和可测试性
publ ic class SpellChecker｛
    //在SpellChecker类中以构造器参数的方式引入Lexicon类
	private final Lexicon dictionary;
    public SpellChecker(Lexicon dictionary) {
    this.dictionary = Objects requireNonNull(dictionary);
	}
    ......
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第六条--避免创建不必要的对象
1）String s='Hello'和 String s=new String('Hello')两种方式是不同的
2）创建 Pattern实例的戚本很高 ，因为需要将正则表达式编译成一个有限状态机，为了提升性能，应该显式地将正则表达式编译成一个 Pattern实例（不可变），让它成为类初始化的一部分，并将它缓存起来
也就是：Pattern pattern=Pattern.compile('正则表达式')的用法
3）定义long型变量：使用long而不是包装类Long,比如在下面的程序中，会生成大量的包装类对象：
变量 sum 被声明成 Long 而不是 long ，意味着程序构造了大约 2^31 个多余的 Long 实例（大约每次往 Long sum 中增加long时构造一个实例） 

private static long sum(){
	Long sum=0L;
	for(long i=0;i<-Integer.MAX_VALUE;i++){
		sum+=i;
	}
	return sum;
}
因此，要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。



	



