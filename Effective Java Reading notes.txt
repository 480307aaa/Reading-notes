【创建和销毁对象】

第一条--用静态工厂方法代替构造器
优点：
静态工厂方法相较于构造器第一大优势，工厂方法有名称，见名知意。
静态工厂方法不需要在每次调用它们时都创建一个新的对象，类似于享元模式，避免创建很多相似的对象
静态工厂方法可以返回原返回类型的任意子类型
缺点：
类如果不含有公有的或者受保护的构造器，就不能被子类化
程序员很难发下它们

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第二条--遇到多个构造器参数时，要考虑使用构造器
Java创建对象的方式：
重叠构造器：第一个构造器只包含必要的参数，第二个构造器包含一个可选参数，第三个构造器包含两个可选参数，以此类推。。。但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读，搞不清每个位置的参数的意义，并且位置容易颠倒。
JavaBean模式：先调用一个午餐构造器来创建对象，然后再调用setter方法来设置每个必要的参数，以及每个相关的可选参数。这种创建对象的方式弥补了重叠构造器方式的不足，每一个参数都清晰明了但是也存在明显的不足，JavaBean模式创建的对象在构造过程中可能处于不一致的状态，因为构造过程被分在了几个调用中。
建造者模式：不直接生成想要的对象，而是由客户端利用所有可用的参数构造器得到一个builder对象，然后客户端在这个builder对象上调用类似于setter的设置方法，最后再调用空的build方法来生成不可变的对象。
Java中的实践方式：
1.类上添加@Builder+@Data注解
2.创建对象的时候使用类似于下面这样的方式来构造这个对象
MeetingSignInListVO.builder()
                .meetingId(id)
                .subject(subject)
                .attendLeaderList(attendLeaderListVO)
                .participantsList(participantsListVO)
                .unitsList(unitsListVO)
                .inviteUser(inviteUserVO)
                .attendances(attendancesVO)
                .alreadySigned(alreadySignedVO)
                .unSigned(unSignedVO)
                .build();
				
Builder模式模拟了具名的可选参数。有重叠构造器模式的安全性，也有JavaBean模式的可读性。如果类的构造器或者静态方法中有比较多的参数，设计类时，使用Builder模式

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第三条--用私有构造器或者枚举类型强化singleton属性
第一种方式：公有静态成员是个final域
public class Elvis {
     public static final Elvis INSTANCE= new Elvis();
     private Elvis(...)
     public void leaveTheBuilding() { ...}
}	 
第二种方式：公有的成员是个静态工厂方法
public class Elvis {
     private static final Elvis INSTANζE = new Elvis();
     private Elvis(...)
     public static Elvis getInstance() ｛return INSTANCE; }
     public void leaveTheBuilding() { ... }
}
第三种方式：声明一个包含单个元素的枚举类型，单元素的枚举类型经常成为实现 Singleton 的最佳方法，但是当Singleton必须扩展一个超类时，而不是扩展Enum时，此方法不合适
public enum Elvis {
     INSTANCE;
     public void leaveTheBuilding() { .. . }
}

序列化当面对单例对象时会遇到问题，将磁盘中对象反序列化至内存中时，会创建多余的对象，此时需要使用readResolve方法，
这样，当JVM从内存中反序列化地"组装"一个新对象时，就会自动调用这个 readResolve方法来返回我们指定好的对象了，单例规则也就得到了保证。
private Object readResolve() throws ObjectStreamException {
       // instead of the object we're on,
       // return the class variable INSTANCE
      return INSTANCE;
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第四条--通过私有构造器强化不可实例化的能力
有时可能需要编写只包含静态方法和静态域的类，比如一些工具类，它们不希望被实例化和子类化，
public class UtilityClass{

	private UtilityClass(){
		throw new AssertionError();
	}
}
// 因为不写throw new AssertionError()时在类内部可以正常初始化，这样就可以保证在类的内外都无法调用此构造方法实例化该类。
企图通过将类做成抽 象类来强制该类不可被实例化是行不通的。让这个类包含一个私有构造器，它就不能被实例化 ,但是这种习惯用法也有副作用，它使得一个类不能被子类化 。 因为所有的构造器都必须显式或隐式地调用超类（ superclass ）构造器，在这种情形下，子类就没有可访问的超类构造器可调用了

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第五条--优先考虑依赖注人来引用资源（一直都在用，但是不知道规则名字）
不要用 Singleton 和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为 ；也不要直接用这个类来创建这些资源 。 而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类 。这个实践就被称作依赖注入，它极大地提升了类的灵活性 、可重用性和可测试性
publ ic class SpellChecker｛
    //在SpellChecker类中以构造器参数的方式引入Lexicon类
	private final Lexicon dictionary;
    public SpellChecker(Lexicon dictionary) {
    this.dictionary = Objects requireNonNull(dictionary);
	}
    ......
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第六条--避免创建不必要的对象
1）String s='Hello'和 String s=new String('Hello')两种方式是不同的
2）创建 Pattern实例的戚本很高 ，因为需要将正则表达式编译成一个有限状态机，为了提升性能，应该显式地将正则表达式编译成一个 Pattern实例（不可变），让它成为类初始化的一部分，并将它缓存起来
也就是：Pattern pattern=Pattern.compile('正则表达式')的用法
3）定义long型变量：使用long而不是包装类Long,比如在下面的程序中，会生成大量的包装类对象：
变量 sum 被声明成 Long 而不是 long ，意味着程序构造了大约 2^31 个多余的 Long 实例（大约每次往 Long sum 中增加long时构造一个实例） 

private static long sum(){
	Long sum=0L;
	for(long i=0;i<-Integer.MAX_VALUE;i++){
		sum+=i;
	}
	return sum;
}
因此，要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第七条--消除过期的对象引用

一旦对象引用已经过期，只需清空这些引用即可
public Object pop(){
	if(size==0){
		throw new EmptyStackException();
	}
	Object result=elements[--size];
	elements[size]=null;
	return result;
}
如果它们以后又被错误地解除引用，程序就会立即抛出 NullPointerException异常,而不是悄悄地错误运行下去

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第八条--避免使用终结方法和清除方法
终结方法（ finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的 。在 Java 9中用清除方法（ cleaner）代替了终结方法 。 清除方法没有终结方法那么危险，但仍然是不可
预测、运行缓慢，一般情况下也是不必要的 。
Java 语言规范不仅不保证终结方法或者清除方法会被及时地执行，而且根本就不保证它们会被执行

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第九条--try-with-resources 优先于 try-finally

旧版关闭资源：
public void test4() {
    InputStream inputStream = null;
    try {
        inputStream = new FileInputStream("D:\\head.jpg");
        // do something
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

这种写法的麻烦之处在于，我们需要在finally块中关闭资源，所以inputStream只能定义在try块的外面。关闭之前，还需要做一步判空，避免因为inputStream为空而导致的空指针异常。这种写法是很繁琐的。

新版关闭资源
同样的功能，如果采用try-with-resources，就会使代码变得非常简洁：
@Test
public void test5() {
    try (InputStream inputStream = new FileInputStream("D:\\head.jpg")) {
        byte[] bytes = inputStream.readAllBytes();
        // do something
    } catch (IOException e) {
        e.printStackTrace();
    }
}

带资源的try语句的3个关键点：

1、由带资源的try语句管理的资源必须是实现了AutoCloseable接口的类的对象。

2、在try代码中声明的资源被隐式声明为fianl。

3、通过使用分号分隔每个声明可以管理多个资源。
当需要关闭的资源有多个，也就是try-finally有嵌套时，如果抛出异常，异常消息可能会出现覆盖，在异常堆轨迹中，完全没有关于第一个异常的记录，这在现实的系统中会导致调试变得非常复杂，
因为通常需要看到第一个异常才能诊断出问题何在。
总结：
try-with-resources可以使代码更加简洁而且不容易出错。相比传统的try-catch-finally的写法，显然try-with-resources优点更多，至少不会存在finally关闭资源因为没判空而导致空指针的问题


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



【对于所有对象都通用的方法】

第十条--覆盖equals时请遵守通用约定
什么时候不需要考虑覆盖equals方法？
1）类的每个实例本质上都是唯一的，比如Thread。
2）类没有必要提供‘逻辑相等’的测试功能，比如正则表达式pattern类，不需要提供两个pattern是否代表同一个正则表达式
3）超类已经覆盖了equals，超类的行为对于这个类也是合适的，比如Set/List/Map,它们都继承自各自的超类AbstractXXX;
4)类时私有的，或者是包级私有的，可以确定它的equals方法永远不会被调用
什么时候需要覆盖equals方法？
先看一下Object的equals方法的源码：比较的是两个对象是否相同，即物理和逻辑都要相等，值相等，并且指向同一段物理地址
 public boolean equals(Object obj) {
        return (this == obj);
 }
如果类具有自己特有的“逻辑相等”（ logical equality ）概念（不同于对象等同的概念），而且超类还没有覆盖 equals 。这通常属于“值类”（ value class ）的情形 。 值类仅仅是一个表示值的类，例如Integer或者String 。程序员在利用equals方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象 。 
下面是String类覆盖equals方法的源码实现：先比较引用，引用一致则相等，否则比较值，值相等则相等。

 public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
 }
下面是Integer基本数据类型覆盖父类equals方法的源码实现：只比较值是否相等
 public boolean equals(Object obj) {
        if (obj instanceof Integer) {
            return value == ((Integer)obj).intValue();
        }
        return false;
 }
 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十一条--覆盖equals时总要覆盖hashCode

1)在每个覆盖了equals方法的类中，都必须覆盖hashCode方法。
2)不要企图让equals方法过于智能 。
3)不要将equals声明中的Object对象替换为其他的类型
相同的实例，其散列码一定相同，不同的实例，其散列码也可能相同
String类的hashCode方法源码：
public int hashCode() {
	int h = hash;
	if (h == 0 && value.length > 0) {
		char val[] = value;

		for (int i = 0; i < value.length; i++) {
			h = 31 * h + val[i];
		}
		hash = h;
	}
	return h;
}
举例说明：假设有一个PhoneNumber类，只需两个实例的prefix和lineNumber属性相等，即可认为两个PhoneNumber相等：（该例子来自于：https://www.jianshu.com/p/6ceec4d542f8）
public class PhoneNumber {
    private short areaCode;
    private short prefix;//关键属性
    private short lineNumber;//关键属性

    public PhoneNumber(short areaCode, short prefix, short lineNumber) {
        this.areaCode = areaCode;
        this.prefix = prefix;
        this.lineNumber = lineNumber;
    }

    public boolean equals(Object o) {
        if(o == this) {
            return true;
        }

        if(!(o instanceof PhoneNumber)) {
            return false;
        }

        PhoneNumber compareO = (PhoneNumber)o;

        return compareO.prefix == this.prefix
                && compareO.lineNumber == this.lineNumber;
    }
}

然后将PhoneNumber与HashMap一起使用：
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(21, 37, 3245), "xiaobai");‘

System.out.println(m.get(new PhoneNumber(53, 37, 3245)));//输出：null
你可能期望输出的是："xiaobai"，因为put和get的两个key对象的equals返回是true，但实际上得到的却是null，为什么呢？原因就在于未覆盖hashCode，两个对象即便相等，但是其hashCode还是可能不等，那么put方法把PhoneNumber对象存放至一个散列桶（hashbucket）中，而get方法却在另外一个散列桶中查找这个对象，当然找不到，退一步说，即便是两个实例刚好被放至于同一个散列桶中，get方法依然还是会返回null，因为HashMap有一项机制：如果两个实例散列码不匹配，直接放弃比较其等同性

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


第十二条--始终要覆盖toString
基本数据类型和String都已经覆盖父类toString方法
Object类的toString()方法源码：它包含类的名称，以及一个“＠”符号，接着是散列码的无符号十六进制表示法，比如MyClass@19765
public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
在实际应用中，toString方法应该返回对象中包含的所有值得关注的信息，无论是否决定指定格式，都应该在文档中明确地表明你的意图，toString方法应该有简洁的格式和详细的描述。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十三条--谨慎地覆盖clone
Cloneable接口不包含任何的方法
public interface Cloneable {
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

第十四条--考虑实现Comparable接口
Comparable接口中只有一个方法：compareTo
public interface Comparable<T> {
	 public int compareTo(T o);
}

类实现了 Comparable 接口，就表明它的实例具有内在的排序关系(natural ordering ）。为实现 Comparable 接口的对象数组进行排序就这么简单 ：Arrays.sort(a);
Java 平台类库中的所有值类(value classes)，以及所有的枚举类型(详见第 34 条)都实现了 Comparable 接口.
Java7之后提供了compare方法去具体实现compareTo方法，比如下面的Integer包装类的compareTo方法的具体实现：
public static int compare(int x, int y) {
	return (x < y) ? -1 : ((x == y) ? 0 : 1);
}
总而言之，每当实现一个对排序敏感的类时，都应该让这个类实现 Comparable 接口，以便其实例可以轻松地被分类 、搜索，以及用在基于比较的集合中 。每当在 compareTo 方法的实现中比较域值时，都要避免使用 ＜ 和＞操作符,两种使用方法：
1）应该在装箱基本类型的类中使用静态的 compare 方法
static Comparator<Object> hashCodeOrder=new Comparator<>(){
	public int compare(Object o1,Object O2){
		return Integer.compare(O1.hashCode,O2.hashCode);
	}
};
2）在 Comparator 接口中使用比较器构造方法 
static Comparator<Object> hashCodeOrder=Comparator.comparingInt(0->o.hashCode());






	



